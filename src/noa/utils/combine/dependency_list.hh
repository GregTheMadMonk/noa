/*****************************************************************************
 *   Copyright (c) 2022, Roland Grinis, GrinisRIT ltd.                       *
 *   (roland.grinis@grinisrit.com)                                           *
 *   All rights reserved.                                                    *
 *   See the file COPYING for full copying permissions.                      *
 *                                                                           *
 *   This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by    *
 *   the Free Software Foundation, either version 3 of the License, or       *
 *   (at your option) any later version.                                     *
 *                                                                           *
 *   This program is distributed in the hope that it will be useful,         *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of          *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the            *
 *   GNU General Public License for more details.                            *
 *                                                                           *
 *   You should have received a copy of the GNU General Public License       *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>.   *
 *                                                                           *
 *   Implemented by: Gregory Dushkin (yagreg7@gmail.com)                     *
 *****************************************************************************/
/**
 * \file dependency_list.hh
 * \brief Static tasks' dependency list handling
 */

#pragma once

#include <type_traits>

#include "task.hh"
#include "template_details.hh"

namespace noa::utils::combine {

template <typename...> struct DependencyList;

namespace detail {

    /// \brief Another operator+ hack. Adds a unique entry to a DependencyList
    ///
    /// Serves as a helper for removing duplicate tasks from the list
    template <typename Task, typename... Tasks>
    auto operator+(DummyT<Tasks...>, Task)
    ->
    std::conditional_t<
        (std::is_same_v<Tasks, Task> || ...),
        DummyT<Tasks...>,
        DummyT<Tasks..., Task>
    >;

    /// \brief See \ref DependencyList::Uniquify
    template <typename... Tasks>
    struct Uniquify {
        using Type = std::remove_reference_t<decltype((std::declval<DummyT<>>() + ... + std::declval<Tasks>()))>;
    };
} // <-- namespace detail

/**
 * \brief Structure that serves as a dependency list for Combine tasks
 *
 * Task dependencies are declared via a nested `Depends` type alias. It
 * must be a `DependencyList` template specification with arguments types
 * equal to types the task dependencies. For tasks with no dependencies, or
 * special types of dependencies, the following utilities are provided:
 *
 * * \ref Nodeps
 * * \ref Either
 * * \ref Optinally
 * * \ref ProviderOf (TODO)
 */
template <typename... Tasks> struct DependencyList {
    static_assert(
        (isTask<Tasks> && ... && true),
        "All DependencyList template arguments are expected to be valid tasks"
    );

    /// \brief Determines whether a specified task is contained within the dependency list
    ///
    /// \tparam Task task to find
    template <typename Task>
    static constexpr bool contains = decltype(detail::hasVArg(std::declval<DependencyList>()))::value;

    /// \brief Determines whether a specified task appears in the class template arguments only once
    ///
    /// \tparam Task task in question
    template <typename Task>
    static constexpr bool isUnique = (std::is_same_v<Tasks, Task> + ...) == 1;

    /// \brief Leaves only one appearance of each entry in the list
    ///
    /// If the task is not unique, the first (left to right) is left
    using Uniquify = typename detail::Uniquify<Tasks...>::Type::template Transform<DependencyList>;

    /// \brief Lists all of the unique dependencies generated by the list tasks
    using Depends = DepListsJoin<typename Tasks::Depends...>;
    
    /// \brief Is the list empty?
    static constexpr bool empty = sizeof...(Tasks) == 0;
}; // <-- struct DependencyList

/// \brief Empty dependency list
using Nodeps = DependencyList<>;

} // <-- namespace noa::utils::combine
